snippet med
	@media (${1:min}-width: ${2}) {
	}
snippet <!
	<!-- ${1} -->
snippet <t
	<!-- TODO: ${1} -->
snippet @me
	@media screen and (${1:max}-width: ${2:320}px) {
	}
snippet ie
	<!--[if IE]>
	<![endif]-->
	<![if !IE]
	<![endif]
snippet i
	<i>${1}</i>
snippet doc
	<!DOCTYPE html>
	<html lang="en">
	  <head>
	    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
	    <title>${1}</title>
	  </head>
	  <body>
	  </body>
	</html>
snippet doctype
	<!DOCTYPE HTML>
snippet a
	<a></a>
snippet abbr
	<abbr></abbr>
snippet address
	<address>
	</address>
snippet area
	<area />
snippet article
	<article>
	</article>
snippet aside
	<aside>
	</aside>
snippet asider supprting information for the main content
	<aside>
	</aside>
snippet audio
	<audio controls="controls" src="${1:http://www.example.com}">
	  Your software does not support this object.
	</audio>
snippet b
	<b></b>
snippet base
	<base />
snippet blockquote
	<blockquote>
	</blockquote>
snippet body
	<body>
	</body>
snippet br
	<br />
snippet button
	<button
	  autoFocus
	  disabled
	  name=""
	  type="button reset submit"
	>${1}</button>
snippet canvas
	<canvas>
	  Your software does not support this object.
	</canvas>
snippet caption
	<caption></caption>
snippet command
	<command>
	</command>
snippet datalist
	<datalist>
	</datalist>
snippet dd
	<dd></dd>
snippet details
	<details>
	</details>
snippet div
	<div>
	</div>
snippet dl
	<dl>
	</dl>
snippet dt
	<dt></dt>
snippet em
	<em></em>
snippet embed
	<embed />
snippet fieldset
	<fieldset>
	</fieldset>
snippet figcaption
	<figcaption></figcaption>
snippet figure
	<figure>
	</figure>
snippet footer
	<footer>
	</footer>
snippet footerc contains metadata that applies to the parent document
	<footer role="contentinfo">
	</footer>
snippet form
	<form>
	</form>
snippet h1
	<h1>${1}</h1>
snippet h2
	<h2></h2>
snippet h3
	<h3></h3>
snippet h4
	<h4></h4>
snippet h5
	<h5></h5>
snippet h6
	<h6></h6>
snippet head
	<head>
	</head>
snippet header
	<header>
	</header>
snippet headerr prime heading or internal title of the page
	<header role="banner">
	</header>
snippet hgroup
	<hgroup>
	</hgroup>
snippet hr
	<hr />
snippet html
	<html>
	</html>
snippet id
	id="${1:[id]}"
snippet iframe
	<iframe />
snippet img
	<img />
snippet input
	<input
	  accept=".doc,.pdf,audio/*,image/*,text/plain,video/*"
	  autoFocus
	  checked
	  disabled
	  inputMode="numeric tel email url"
	  max=""
	  maxLength=""
	  min=""
	  multiple
	  name=""
	  pattern="<regex>"
	  placeholder=""
	  readOnly
	  required
	  spellCheck
	  src="<image URI>"
	  step=""
	  type="button checkbox color date datetime-local email file hidden image month number password radio range reset search submit tel text time url week"
	  value=""
	  width=""
	/>
snippet keygen
	<keygen />
snippet label
	<label htmlFor="${1}">${2}</label>
snippet legend
	<legend></legend>
snippet li
	<li></li>
snippet link
	<link />
snippet map
	<map>
	</map>
snippet mark
	<mark></mark>
snippet menu
	<menu>
	</menu>
snippet meta charset
	<meta charset="${1:utf-8}" />
snippet meta description
	<meta name="description" content="${1}">
snippet meta http-equiv (generic)
	<meta http-equiv="${1}" content="${2}" />
snippet meta http-equiv for IE edge
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
snippet meta name
	<meta name="${1}" content="${2}" />
snippet meta viewport
	<meta name="viewport" content="initial-scale=1.0, width=device-width" />
snippet meter
	<meter></meter>
snippet nav
	<nav>
	</nav>
snippet noscript
	<noscript>
	</noscript>
snippet object
	<object>
	</object>
snippet ol
	<ol>
	</ol>
snippet optgroup
	<optgroup>
	</optgroup>
snippet option
	<option></option>
snippet output
	<output></output>
snippet p
	<p>
	</p>
snippet param
	<param>
snippet pre
	<pre>
	</pre>
snippet progress
	<progress></progress>
snippet q
	<q></q>
snippet script inline statements
	<script>
	</script>
snippet script external source
	<script src="${1:http://www.example.com}"></script>
snippet section
	<section>
	</section>
snippet sectionr main content of the document
	<section>
	</section>
snippet select
	<select>
	</select>
snippet small
	<small></small>
snippet source
	<source />
snippet span
	<span></span>
snippet sty
	style="${1}"
snippet style
	<style>
	</style>
snippet sub
	<sub></sub>
snippet summary
	<summary></summary>
snippet sup
	<sup></sup>
snippet table
	<table>
	</table>
snippet tbody
	<tbody>
	</tbody>
snippet td
	<td></td>
snippet textarea
	<textarea>
	</textarea>
snippet tfoot
	<tfoot>
	</tfoot>
snippet th
	<th></th>
snippet thead
	<thead>
	</thead>
snippet time
	<time></time>
snippet title
	<title></title>
snippet tr
	<tr>
	</tr>
snippet ul
	<ul>
	</ul>
snippet video
	<video>
	  Your software does not support this object.
	</video>
snippet jsv
	javascript: void(0);
snippet main
	<main>
	</main>
snippet gat
	className=""
	id=""
	style=""
	tabIndex="0"
	title=""
snippet rf
	import React from 'react';
	
	export function ${1:name}(${2}) {
	  return <span>${3:$1}</span>;
	}
	
	export default ${4:$1};
snippet rc
	import React, { Component } from 'react';
	
	export class ${1:Component} extends Component {
	  // static methods
	  // static propTypes = {};
	  // static defaultProps = {};
	  // state = {};
	  // instance variables
	
	  ///////////////////////////////////////////////////////////////////////////
	  // MOUNTING: invoked, in order, when component is inserted into DOM.
	  //
	  // constructor(props) {}
	  //
	  // Invoked before render(), on initial mount and updates. For rare
	  // cases when state depends on changes in props over time.
	  // static getDerivedStateFromProps(props, state) {}
	  //
	  // render() {}
	  //
	  // Invoked after mount. For initialization requiring DOM, loading
	  // data from network, setting up subscriptions and timers, etc.
	  // componentDidMount() {}
	
	  ///////////////////////////////////////////////////////////////////////////
	  // UPDATING: invoked, in order, when component is re-rendered.
	  //
	  // Invoked before render(), on initial mount and updates. For rare
	  // cases when state depends on changes in props over time.
	  // static getDerivedStateFromProps(props, state) {}
	  //
	  // Invoked before render() when new props or state are received. For
	  // performance optimization, not to prevent rendering.
	  // shouldComponentUpdate(nextProps, nextState) {}
	  //
	  // render() {}
	  //
	  // Invoked before rendered output is committed to DOM. For capturing
	  // information from DOM before it's changed.
	  // getSnapshotBeforeUpdate(prevProps, prevState) {}
	  //
	  // Invoked after update. For operating on DOM, loading data from
	  // network, etc.
	  // componentDidUpdate(prevProps, prevState, snapshot) {}
	
	  ///////////////////////////////////////////////////////////////////////////
	  // UNMOUNTING: invoked when component is removed from DOM.
	  //
	  // Invoked before component is unmounted and destroyed. For
	  // performing cleanup on subscriptions and timers, canceling network
	  // requests, etc.
	  // componentWillUnmount() {}
	
	  ///////////////////////////////////////////////////////////////////////////
	  // ERROR HANDLING: invoked when there's an error during rendering, in a
	  // lifecycle method, or in constructor of any child component.
	  //
	  // Invoked after error was thrown by descendant component. For
	  // returning value to update state.
	  // static getDerivedStateFromError(error) {}
	  //
	  // Use to handle error in tree, e.g. logging.
	  // componentDidCatch(error, info) {}
	
	  render() {
	    return <span>${3:$1}</span>;
	  }
	
	  // render helper methods (e.g. renderNavigation())
	  // event handlers and callbacks (e.g. handleChange = () => {};)
	  // utility methods
	}
	
	export default ${4:$1};
snippet rmtc
	import ${1:Component} from './${2:$1}';
	import React from 'react';
	import ReactDOM from 'react-dom';
	
	describe('${3:$1}', function() {
	  it('renders successfully', function() {
	    const container = document.createElement('div');
	    ReactDOM.render(<${4:$1} />, container);
	  });
	
	  // FIXME add more tests once Enzyme supports hooks
	});
snippet rrc
	import { connect } from 'react-redux';
	import ${1:PresentationalComponent} from '../components/${2:$1}';
	
	export const mapStateToProps = (state, ownProps) => ({
	});
	
	export const mapDispatchToProps = (dispatch, ownProps) => ({
	});
	
	export const ${3:$1}Container = connect(
	  mapStateToProps,
	  mapDispatchToProps
	)(${4:$1});
	
	export default ${5:$1}Container;
snippet rtrc
	import { mapStateToProps, mapDispatchToProps } from './${1}';
	
	describe('mapStateToProps()', () => {
	  it.skip('returns an object mapped from state', () => {
	    const state = {
	    };
	    expect(mapStateToProps(state)).toEqual({
	    });
	  });
	});
	
	describe('mapDispatchToProps', () => {
	  describe('returned object mapped from dispatch', () => {
	  });
	});
snippet rrr
	export const initialState = {
	};
	
	export function ${1:reducer}(state = initialState, action) {
	  switch (action.type) {
	    default:
	      return state;
	  }
	}
	
	export default ${2:$1};
snippet rra
	export const actionTypes = {
	};
	
	export const actions = {
	};
snippet rtrr
	import {
	  initialState,
	  ${1:function}
	} from './${2:$1}';
	
	describe('${3:$1}()', () => {
	  describe('when action.type is unrecognized', () => {
	    it('returns previous state', () => {
	      const action = { type: 'UNRECOGNIZED' };
	      expect(${4:$1}(initialState, action)).toEqual(initialState);
	    });
	  });
	});
snippet rtra
	import { actions, actionTypes } from './${1}';
	import { isFSA } from 'flux-standard-action';
	
	describe('actions', () => {
	});
snippet rtesting
	// Test render() and other "public" methods for these things:
	// * Output - significant or variable rendered content
	// * Side-effects - simulated events, "child" interaction, prop
	//   function calls, lifecycle method effects, timers, etc.
	// * Error handling
	// * Boundary condition handling
	//
	// Avoid testing:
	// * Declarative code which would need to be duplicated in the test.
	// * Behavior of code outside this unit (frameworks, libraries, etc.).
snippet rhoc
	import React from 'react';
	
	export function with${1:Component}(WrappedComponent) {
	  const With${2:$1} = React.fowardRef((props, ref) => {
	    return <WrappedComponent {...props} ref={ref}/>;
	  });
	
	  const wrappedComponentName = WrappedComponent.displayName
	    || WrappedComponent.name
	    || 'Component';
	
	  With${3:$1}.displayName = \`with${4:$1}(${wrappedComponentName})\`;
	  return With${5:$1};
	}
snippet rpt
	import PropTypes from 'prop-types';
	
	const propTypes = {
	};
	
	const defaultProps = {
	};
	
	${1:Component}.propTypes = propTypes;
	${2:$1}.defaultProps = defaultProps;
snippet rlimp
	const ${1:Component} = React.lazy(() => import('./${2:$1}'));
snippet pt
	PropTypes.${1}
snippet tp
	this.props.${1}
snippet ts
	this.state.${1}
snippet tb
	toBe(${1:value});
snippet thbc
	toHaveBeenCalled();
snippet thbct
	toHaveBeenCalledTimes(${1:number});
snippet thbcw
	toHaveBeenCalledWith(${1:argument});
snippet thblcw
	toHaveBeenLastCalledWith(${1:argument});
snippet tbct
	toBeCloseTo(${1:number}, ${2:numberOfDigits});
snippet tbd
	toBeDefined();
snippet tbf
	toBeFalsy();
snippet tbgt
	toBeGreaterThan(${1:number});
snippet tbgte
	toBeGreaterThanOrEqual(${1:number});
snippet tbelt
	toBeLessThan(${1:number});
snippet tblte
	toBeLessThanOrEqual(${1:number});
snippet tbio
	toBeInstanceOf(${1:Class});
snippet tbn
	toBeNull();
snippet tbt
	toBeTruthy();
snippet tbu
	toBeUndefined();
snippet tc
	toContain(${1:item});
snippet tce
	toContainEqual(${1:item});
snippet te
	toEqual(${1:value});
snippet thl
	toHaveLength(${1:number});
snippet tm
	toMatch(new RegExp(${1:regexp}));
snippet tmo
	toMatchObject(${1:object});
snippet tms
	toMatchSnapshot();
snippet tt
	toThrow();
snippet tte
	toThrowError(${1:error});
snippet ttems
	toThrowErrorMatchingSnapshot();
snippet typ
	type ${1:TType} = ${2};
snippet int
	interface ${1:IInterface} {
	}
